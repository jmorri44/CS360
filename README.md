# CS360

This mobile application was designed to allow users to create and maintain a record of in-hand inventory. The app maintains a database containing a name and count for each inventory item, which the user can view as a list from the main app screen. The app also provides a login feature, allowing users to limit access. 

The app has three screens that support its primary functions. The first, the login screen, accepts input from the user in the form of a username and password, and verifies this input against the user database. For the purposes of the local application, the screen also allows users to freely create new user/password combinations that all access the same database. Account creation uses a separate screen that also accesses the user database.
Once past the login screen, the user is presented with a list view that displays all of the items currently in the inventory database. New items can be added via a floating action button, and users can view and edit each item's details by tapping on it. Both of these features use the same activity and layout screen, but a different layout is presented depending on whether the user is adding a new item, or editing an existing one. In addition to adding items and editing, the user can delete items in one of two ways. The first is to press the 'delete' button located on the item's entry in the inventory list. The second is to edit the item's count to zero via the item edit screen. In the latter case, the app will display a dialog asking if the user wishes to remove the item from the list, or maintain an entry of zero. 
The purpose behind this logic is to provide an intuitive approach to inventory management. In the case of editing an item to zero, the user may not initially realize that they wish to remove the item, and if the list of items is long, it could be a waste of time to first edit an item to zero, then, on realizing the item should have been removed, locate it again in the list. If the user did not wish to remove the item, it is a simple matter of dismissing the dialog and continuing.

Design and testing of the code was done one module at a time. Each layout and its underlying model were tested for functionality, before linked together into the final product. This process allowed the majority of errors to be addressed while still contained within a relatively small snippet of code, and largely eliminated the need for extensive crash tracing. By ensuring that the model was functional and eliminating errors in the controller/view setup early on, I was able to focus my debugging of the final app to interactions between the components, rather than wasting time tracing errors within the components themselves.

I feel that the most practically successful (while not _entirely_ innovative) element of this application is the dual-purpose item edit screen. I was successful in creating a view layout that could be manipulated through the code to display and function in two different ways, depending on the context with which it was launched. The result allows the app to perform two different tasks using the same layout and activity files, thus reducing space required, and cutting down on the app's overall complexity. 
